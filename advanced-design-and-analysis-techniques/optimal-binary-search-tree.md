## 最优二叉搜索树

假定我们正在设计一个程序，实现英语文本到法语的翻译。对英语文本中出现的每个单词，我们需要查找对应的法语单词。为了实现这些查找操作，我们可以创建一棵二叉搜索树，将 n 个英语单词作为关键字，对应的法语单词作为关联数据。由于对文本中的每个单词都要进行搜索，我们希望花费在搜索上的总时间尽量少。通过使用红黑树或其它平衡搜索树结构，我们可以假定每次搜索时间为 O(lgn)。但是单词出现的频率是不同的，像 "the" 这种频繁使用的单词有可能位于搜索树中远离根的位置上，而像 "machicolation" 这种很少使用的单词可能位于靠近根的位置上。这样的结构会减慢翻译的速度，因为在二叉搜索树中搜索一个关键字需要访问的结点数等于包含关键字的结点的深度加 1。我们希望文本中频繁出现的单词被置于靠近根的位置。而且，文本中的一些单词可能没有对应的法语单词，这些单词根本不应该出现在二叉搜索树中。在给定单词出现频率的前提下，我们应该如何组织一棵二叉搜索树，使得所有搜索操作访问的结点总数最少呢？

这个问题称为最优二叉搜索树（optimal binary search tree）问题。其形式化定义如下：给定一个 n 个不同关键字的已排序的序列 K = <k<sub>1</sub>, k<sub>2</sub>, ..., k<sub>n</sub>>（因此 k<sub>1</sub> < k<sub>2</sub> < ... < k<sub>n</sub>），我们希望用这些关键字构造一棵二叉搜索树。对每个关键字 k<sub>i</sub>，都有一个概率 p<sub>i</sub> 表示其搜索频率。有些要搜索的值可能不在 K 中，因此我们还有 n + 1 个“伪关键字” d<sub>0</sub>, d<sub>1</sub>, d<sub>2</sub>, ..., d<sub>n</sub> 表示不在 K 中的值。d<sub>0</sub> 表示所有小于 k<sub>1</sub> 的值，d<sub>n</sub> 表示所有大于 k<sub>n</sub> 的值，对 i = 1, 2, ..., n-1，伪关键字 d<sub>i</sub> 表示所有在 k<sub>i</sub> 和 k<sub>i+1</sub> 之间的值。对每个伪关键字 d<sub>i</sub>，也有一个频率 p<sub>i</sub> 表示对应的搜索频率。下图显示了一个 n = 5 个关键字的集合构造的两棵二叉搜索树。每个关键字 k<sub>i</sub> 是一个内部结点，而每个伪关键字 d<sub>i</sub> 是一个叶结点。每次搜索要么成功（找到某个关键字 k<sub>i</sub>）要么失败（找到某个伪关键字 d<sub>i</sub>），因此有如下公式：

![](../assets/images/part4/optimal-binary-search-tree.png)

![](../assets/images/part4/optimal-binary-search-tree2.png)

对一个 n = 5 的关键字集合及如下的搜索频率，构造的两棵二叉搜索树：

|    i       | 0     | 1 | 2 | 3 | 4 | 5 |
|:----------|:------|:------|:------|:------|:------|:------|
| p<sub>i</sub>  |    | 0.15  | 0.10  | 0.05  |0.10  |0.20  |
| q<sub>i</sub>    | 0.05  | 0.10  |0.05  |0.05  |0.05  |0.10 |

（a）期望搜索代价为 2.80 的二叉搜索树。（b）期望搜索代价为 2.75（最优）的二叉搜索树






















