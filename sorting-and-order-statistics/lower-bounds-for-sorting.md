## 排序算法的下界

到目前为止，我们介绍了几种能在 O(n * lgn) 时间内排序 n 个数的算法，归并排序和堆排序达到了最坏情况下的上界，快速排序在平均情况下达到该上界。而且，对于这些算法中的每一个，我们都能给出 n 个输入数值，使得该算法能在 Ω(n * lgn) 时间内完成。

这些算法都有一个有趣的性质：在排序的最终结果中，各元素的次序依赖于它们之间的比较。我们把这类排序算法称为比较排序，到目前为止，我们介绍的所有排序算法都是比较排序。

在一个比较排序算法中，我们只使用元素间的比较来获得输入序列 [a1, a2, ..., an] 中的元素次序的信息。也就是说，给定两个元素 ai 和 aj，可以执行 ai < aj，ai <= aj，ai = aj，ai >= aj 或者 ai > aj 中的一个比较操作来确定它们之间的相对次序，我们不能用其它方法观察元素的值或者它们之间的次序信息。

不失一般性，我们不妨假设所有的输入元素都是互异的，给定了这个假设后， ai = aj 的比较就没有意义了。因此，我们可以假设不需要这种比较。同时，注意到 ai <= aj、ai >= aj、ai > aj 和 ai < aj 都是等价的，因为通过它们所得到的关于 ai 和 aj 的相对次序的信息都是相同的。这样，又可以进一步假设所有比较采用的都是 ai <= aj 形式。

### 决策树模型

比较排序可以被抽象为一棵决策树。决策树是一棵完全二叉树，它可以表示在给定输入规模情况下，某一特定排序算法对所有元素的比较操作。其中，控制、数据移动等其它操作都被忽略了。下图显示了插入排序算法作用于包含三个元素的输入序列的决策树情况。

![](../assets/images/part1/decision-tree.png)

在决策树中，每个内部结点都以 i : j 标记，其中，i 和 j 满足 1 <= i，j <= n，n 是输入序列中的元素个数。每个叶结点上都标注一个序列 [s[1], s[2], ..., s[n]]。排序算法的执行对应于一条从数的根结点到叶结点的路径。每一个内部结点表示一次比较 ai <= aj。